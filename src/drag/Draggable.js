/** * @author Garrett Smith  * @version 1 * @fileoverview: * contains: APE.drag.Draggable, DragHandlers, APE.drag.DropTarget * * @requires APE.EventPublisher, APE.dom *  * classNames: * <ul> *   <li>activeDragClassName</li> *   <li>selectedClaslusName</li> *   <li>dragOverClassName (for dropTarget)</li> * </ul> * * APE.drag.Draggable Features: * <ul> *   <li>dragCopy</li> *   <li>dragMultiple</li> *   <li>setHandle(handle, useTree)</li> * </ul> * * @example Create a Draggable: *<pre> * var Draggable = APE.drag.Draggable, *     el = document.getElementById(<var>"box"</var>), *     box = Draggable.getByNode( el ); * box.keepInContainer = true; * box.activeDragClassName = "boxDragging"; *  * var bigBx = box.addDropTarget( document.getElementById("biggerBox") ); * bigBx.dragOverClassName = "boxDragOver"; * </pre> *//** @name APE.drag.Draggable * @namespace */APE.namespace("APE.drag");(function(){    var APE = self.APE,        dom = APE.dom,        drag = APE.drag,        EventPublisher = APE.EventPublisher,        highestZIndex = 1000,        draggableList = { },        Draggable = APE.createFactory(Drag, createDraggablePrototype);        drag.Draggable = Draggable;        Draggable.instanceDestructor = instanceDestructor;        /**      * @private     * @description Do not call the constructor directly.     * @param {HTMLElement} el the element to drag.     */    function Drag(el) {        this.id = el.id;        this.el = this.origEl = el;        this.style = el.style;        this.isRel = dom.getStyle(el, "position").toLowerCase() == "relative";            // default 'container' is the containing block.        this.container = (this.isRel ? el.parentNode : dom.getContainingBlock(el));        this.dropTargets = [];        this.handle = el;        this.onbeforeexitcontainer = beforeExitContainer;        el.style.zIndex = dom.getStyle(el, "zIndex") || highestZIndex++;        setIeTopLeft(el);    }            /** Will be dragged */    function beforeExitContainer() { return !this.keepInContainer; }        /** @name APE.drag.instanceDestructor */    function instanceDestructor() {        var x, p, dObj;        for(x in this.instances) {            dObj = this.instances[x];            for(p in dObj)                if(dObj.hasOwnProperty(p))                     delete dObj[p];            delete this.instances[x];        }        draggableList = {};        dO = null;    }        // For some browsers (IE and Safari), the currentStyle/computedStyle     // for top/left will be "auto" when bottom and right values are set.    function setIeTopLeft(el) {         // For IE, set top/left values when declared values are auto        // and right/bottom values are given.        var s = el.style, cs,            cb = dom.getContainingBlock(el);                if(dom.IS_COMPUTED_STYLE) {            cs = document.defaultView.getComputedStyle(el,"");        } else {            cs = el.currentStyle || s;        }                var curL = cs.left,             curR = cs.right,             curT = cs.top,            curB = cs.bottom;                // Calculate left when right is given pixel value and left is "auto".        if((curL === "" || curL === "auto")) {            curR = parseInt(curR, 10);            if(isFinite(curR))                s.left = cb.clientWidth - el.offsetWidth - curR + "px";            else s.left = "0";        }                // Calculate top when bottom is given pixel value and top is "auto".        if((curT === "" || curT === "auto")) {            curB = parseInt(curB, 10);            if(isFinite(curB)) {                s.top = cb.clientHeight - el.offsetHeight - curB + "px";            }            else s.top = "0";        }    }            function createDraggablePrototype(){                // Static initializer code.        var d = self.document,            ds = d.documentElement.style,            serSelect = "serSelect",             mus = "MozU"+serSelect,            kus = "MozU"+serSelect,            us = "u"+serSelect,            userSelectType = mus in ds ? mus : kus in ds ? kus : us in ds ? us : "",            isUnselectable = 'unselectable' in d.documentElement,            PIXEL_PX = "px",            LSTYLE = "left",            TSTYLE = "top",            mousedownX = 0,            mousedownY = 0,            dO,            mouseMoveThreshold = 0,            lastMouseMoveTime = -1,            getEventCoords = dom.Event.getCoords;        // prevent text selection while dragging.        if('onselectstart' in d) {            EventPublisher.get(d, "onselectstart").addBefore(preventUserSelection);        } else {            EventPublisher.get(d, "onmousedown").addAfter(preventUserSelection);            EventPublisher.get(d, "onmouseup").addAfter(preventUserSelection);        }        if('pixelLeft'in ds){            PIXEL_PX = 0;            LSTYLE = "pixelLeft";            TSTYLE = "pixelTop";        }        EventPublisher.add(d, "onmousedown", mouseDown);        EventPublisher.add(d, "onkeypress", keyPressed);        EventPublisher.add(d, "onmousemove", mouseMove);        EventPublisher.add(d, "onmouseup", mouseUp);        function preventUserSelection(ev) {            if(userSelectType) {                this.documentElement.style[userSelectType] = dO ? "none" : "";            } else if(!ev) {                window.event.returnValue = false;            }        }        d = ds = null;                /** @param {HTMLElement} target Element that is checked.*/        function isInHandle(dObj, target) {            return target === dObj.handle ||             (dObj.useHandleTree && dom.contains( dObj.handle, target ));        }        /**          * Selects the draggable, adding selectedClassName         * @param {boolean} isSelect if false, deselects.         */        function select(dObj, isSelect) {            if(isSelect) {                if(dObj.selectedClassName)                    dom.addClass(dObj.el, dObj.selectedClassName);                // onselect handler would go here, if/when needed. return false to prevent.                                if(dObj.dragMultiple && ! (dObj.id in draggableList)) {                    draggableList[dObj.id] = dObj;                }            } else {                if(dObj.selectedClassName)                    dom.removeClass(dObj.el, dObj.selectedClassName);                // ondeselect handler would go here, if/when needed.                delete draggableList[dObj.id];            }            dObj.isSelected = Boolean(isSelect);        }                /* Called from dragStart. Sets initial x/y position values. */        function setUpCoords(e, newDo) {            var container = newDo.container,                el = newDo.el,                cb = dom.getContainingBlock(el),                coords = dom.getOffsetCoords(cb, container),              // subtract in-flow offsets.                pixelCoords = dom.getPixelCoords(el),              // Due to the AVK-CSSOM Mess, offsetTop/offsetLeft are broken - DO NOT USE offset*!              // Instead, use getOffsetCoords(el, el.parentNode);                offsetFromParent = dom.getOffsetCoords(el, el.parentNode),                inFlowOffsetX = offsetFromParent.x - pixelCoords.x + coords.x,                inFlowOffsetY = offsetFromParent.y - pixelCoords.y + coords.y;                        // Safari Bug: if el is inside a TD, safari adds the TD's offsetLeft to the                 // el's offsetLeft, even if the TD has position: relative.                         // Impl Note: Don't use margins for absolutely positioned elements for Safari.                // Safari calculates offsetTop from parentNode border edge (not padding edge).                         // Safari 1.3 can't read style values from styleSheets.                // Safari 1.3 also adds parentNode border-width to offsetLeft.                 // Safari 3 does not. TODO: test Safari 2.                // Safari 1.3 adds padding-left and top to inFlowOffsets, Safari 3 does not.                // Safari 1 can't read styles. TODO: test Safari 2.                         if(newDo.keepInContainer) {                newDo.minX = 0 - inFlowOffsetX;                newDo.maxX = container.clientWidth - newDo.el.offsetWidth - inFlowOffsetX;                newDo.minY = 0 - inFlowOffsetY;                newDo.maxY = container.clientHeight - newDo.el.offsetHeight - inFlowOffsetY;            }        }                function removeGroupSelection() {            for(var id in draggableList) {                select(draggableList[id], false);            }        }                /**          * returns true if there are any selected items.         */        function hasGroupSelection() {            for(var id in draggableList)                return true;            return false;        }               /**         * When a draggable has been released (by ESC), it calls dragout from the relevant          * droptargets and resets any active over droptargets.         * @param {Event} e the event that triggered the release. This gets passed back to ondragout.         * @param {Draggable} the draggable object that was released.         */         function dragObjReleased(e, dO) {            dO.animateBack();            var removeClass = dom.removeClass,                dt, i = 0, j = dO._dragOverTargets.length, id;            if(dO._dragOverTargets !== false) {                for(; i < j; i++) {                    dt = dO._dragOverTargets[i];                    // Did we just move off dO dropTarget?                    if(dt.hasDropTargetOver) {                        if(typeof dt.ondragout == "function")                            dt.ondragout(e, dO);                        if(dt.dragOverClassName)                            removeClass(dt.el, dt.dragOverClassName);                        dt.hasDropTargetOver = false;                    }                }            }            for(id in draggableList) {                draggableList[id].animateBack();            }            dO = null;        }                function dragDone(dObj, e) {            if(dObj.activeDragClassName)                dom.removeClass(dObj.el, dObj.activeDragClassName);            if(typeof dObj.ondragend == "function" && dObj.hasBeenDragged) {                dObj.ondragend(e);            }            if(dObj.copyEl) { // in case user does some appending of el, et c.                dObj.el.parentNode.insertBefore(dObj.copyEl, dObj.el);            }            dObj.hasBeenDragged = false;        }        function setGroupSelection(dObj, hasMetaKey) {            if(hasMetaKey) {                if(dObj.id in draggableList) { // selected.                    select(dObj, false);                } else { // not selected.                    select(dObj, true);                }            } else if(!dObj.isSelected) { // if not selected, deselect others.                removeGroupSelection(); // (it may be empty)                select(dObj, true);            }        }                /* creates a copyEl for dragCopy */        function assignClone(dObj) {            var addClass = "addClass",                copyEl,                el = dObj.el,                origEl = el,                copyElStyle;            if(!dObj.copyEl) {                dObj.origEl = el;                dObj.copyEl = el.cloneNode(true);                dObj.copyEl.id += "Copy";            }            copyEl = dObj.copyEl;            copyElStyle = copyEl.style;                        copyElStyle.display = "";            if(copyEl.parentNode !== el.parentNode)            // In case the element was appened elsewhere, by external script                el.parentNode.insertBefore(copyEl, el);            // 100 draggable items appear above.            copyElStyle.zIndex = parseInt(origEl.style.zIndex) + 100;            if(dObj.origClassName)                dom[addClass](el, dObj.origClassName);                        dObj.el = copyEl;            dObj.style = copyElStyle;            // This helps prevent copyEl from displacing other elements.            if(dObj.isRel) {                copyElStyle.marginBottom = -origEl.offsetHeight +                     -(parseInt(dom.getStyle(origEl, "marginBottom"))||0) + "px";                copyElStyle.marginright = -origEl.offsetWidth +                     -(parseInt(dom.getStyle(origEl, "marginRight"))||0) + "px";            }        }                function retireClone(dObj) {                if(dObj.copyEl.style.display == "none") return;                    dObj.el = dObj.origEl;            dObj.style = dObj.origEl.style;                        // Update position of origEl, which was left behind.            dObj.moveToX(dObj.x);            dObj.moveToY(dObj.y);            dObj.copyEl.style.display = "none";            if(dObj.origClassName)                dom.removeClass(dObj.el, dObj.origClassName);        }        /**         * called on mousemove          */        function carryGroup(distX, distY) {            var o, id;            for(id in draggableList) {                o = draggableList[id];                if(distX != null)                    o.moveToX( o.origX + distX );                if(distY != null)                    o.moveToY( o.origY + distY );            }        }        function dragStart(dObj, e) {            if(dObj.isBeingDragged) return;                if(dObj.dragCopy) {                assignClone(dObj);  // dObj.el assigned to copyEl, dObj.origEl stays put.            }            if(typeof dObj.ondragstart == "function")                dObj.ondragstart(e);                if(dObj.activeDragClassName)                 dom.addClass(dObj.el, dObj.activeDragClassName);            // Check the coords after making the copyEl here.            setUpCoords(e, dObj);            dObj.isBeingDragged = true;         }        function mouseDown(e) {             if(!e)                 e = self.event;                            var target = dom.Event.getTarget(e),                dOTarg = null,                instances = Draggable.instances,                testNode = target;                for(;dOTarg == null && testNode; testNode = dom.findAncestorWithAttribute(testNode, "id"))                dOTarg = instances[testNode.id];            var metaKey = e.metaKey || (/Win/.test(navigator.platform) && e.ctrlKey);                if(dOTarg) { // found.                             if(!dOTarg.isDragEnabled) {                    if(!metaKey) {                        removeGroupSelection();                    }                    return false; // prevent focus.                }                                // If it's got a handle, make sure user clicked the handle.                if(!metaKey && dOTarg.hasHandleSet && !isInHandle(dOTarg, target) ) {                    removeGroupSelection();                    dOTarg = null;                    return;                } else {                    if(!metaKey && !dOTarg.isSelected) { // no metaKey,                         removeGroupSelection();                    }                    e.returnValue = false;                }                // In Mozilla; the intrisinc focus event will not fire when the                 // mousedown calls preventDefault(). This is a bug in Mozilla.                //else if(typeof e.preventDefault == "function") e.preventDefault();            } else {                if(!metaKey) {                    removeGroupSelection();                    if(dO){                        select(dO, false);                        dO = null;                    }                }                return;            }                // User tried to add to selection, but can't. Just return.            if(metaKey && dO && !dOTarg.dragMultiple) {                return false;            }                        if(!dOTarg.dragMultiple) {                if(!metaKey)                    removeGroupSelection();                    // User tried to add to group. Just exit.                else return false;            }                        setGroupSelection(dOTarg, metaKey);                        dOTarg.style.zIndex = ++highestZIndex;                // User tried to drag a group and still had metaKey down.            if(metaKey) { }                        // Sets up dropTargets that have dragOverClassName | ondragover             _setUpDragOver(dOTarg);            dragObjGrabbed(e, dOTarg);                       for(var id in draggableList) {                dragObjGrabbed(e, draggableList[id]);            }            dO = dOTarg;                        return target.tagName !== "IMG"; // Mozilla will prevent focus events for return false;        }                /**          * Called from grab() and from mousemove, when first started.         */        function dragObjGrabbed(e, dObj) {            if(typeof dObj.onbeforedragstart == "function"                 && dObj.onbeforedragstart(e) == false) return true;            var eventCoords = dom.Event.getCoords(e),                elementPixelCoords;                        mousedownX = eventCoords.x;            mousedownY = eventCoords.y;                        elementPixelCoords = dom.getPixelCoords(dObj.el);            dObj.origX = dObj.grabX = elementPixelCoords.x;            dObj.origY = dObj.grabY = elementPixelCoords.y;            dObj.isBeingDragged = false;        }        /**         * mousemove callback handler.         */        function mouseMove(e) {                            if(dO == null) return;                        var now = +new Date;            if(now - lastMouseMoveTime < mouseMoveThreshold) return;            lastMouseMoveTime = now;                        e = e || window.event;            var eventCoords = getEventCoords(e),                ePageX = eventCoords.x, ePageY = eventCoords.y,                distX = ePageX - mousedownX,                distY = ePageY - mousedownY;                        // drag the bitch.            if(dO.isBeingDragged == false) {                dragStart(dO, e);                                for(var id in draggableList) {                    dragStart(draggableList[id], e);                             }            }            dO.newX = dO.origX + distX;            dO.newY = dO.origY + distY;                dO.hasBeenDragged = (dO.hasBeenDragged || (distX || distY));                        var isLeft = dO.newX < dO.minX,                isRight = dO.newX > dO.maxX,                isAbove = dO.newY < dO.minY,                isBelow = dO.newY > dO.maxY;                if(typeof dO.onbeforedrag == "function" && dO.onbeforedrag(e) == false) return;                        var isOutsideContainer = dO.container != null,                hasOnDrag = (typeof dO.ondrag == "function"),                isBeforeExitContainerFunction = typeof dO.onbeforeexitcontainer == "function",                planesStopped = 0;                            isOutsideContainer &= ( isLeft || isRight || isAbove || isBelow );                        if(isOutsideContainer && (isBeforeExitContainerFunction ||                                     dO.onbeforeexitcontainer() == false)) {                if(isLeft) {                    if(!dO.isAtLeft) {                        dO.moveToX( dO.minX );                        // dO.minX - dO.origX = max possible negative distance to travel.                        carryGroup(dO.minX - dO.origX, null);                        if(hasOnDrag)                            dO.ondrag(e);                        dO.isAtRight = false;                        dO.isAtLeft = true;                        planesStopped += 1;                    }                } else if(isRight) {                    if(!dO.isAtRight) {                        dO.moveToX( dO.maxX );                        // dO.maxX - dO.origX = max possible positive distance to travel.                        carryGroup(dO.maxX - dO.origX, null);                        if(hasOnDrag)                            dO.ondrag(e);                        dO.isAtRight = true;                        dO.isAtLeft = false;                        planesStopped += 1;                    }                } else {                    dO.isAtLeft = dO.isAtRight = false;                    dO.moveToX( dO.newX );                    carryGroup(distX, null);                }                if(isAbove) {                    if(!dO.isAtTop) {                        dO.moveToY( dO.minY );                        // dO.minY - dO.origY = max possible positive distance to travel.                        carryGroup(null, dO.minY - dO.origY);                        if(hasOnDrag)                            dO.ondrag(e);                        dO.isAtTop = true;                        dO.isAtBottom = false;                        planesStopped += 1;                    }                } else if(isBelow) {                    if(!dO.isAtBottom) {                        if( dO.maxY > 0 )                            dO.moveToY( dO.maxY );                        // dO.maxY - dO.origY = max possible positive distance to travel.                        carryGroup(null, dO.maxY - dO.origY);                        if(hasOnDrag)                            dO.ondrag(e);                        dO.isAtTop = false;                        dO.isAtBottom = true;                        planesStopped += 1;                    }                } else {                    dO.isAtTop = dO.isAtBottom = false;                    dO.moveToY( dO.newY );                    carryGroup(null, distY);                }                                dO.isDragStopped = planesStopped == 2;                                if(dO.isDragStopped && typeof dO.ondragstop == "function")                    dO.ondragstop(e);                else                     if(hasOnDrag)                        dO.ondrag(e);            }            else {            // In container.                dO.isDragStopped = dO.isAtLeft = dO.isAtRight =                    dO.isAtTop = dO.isAtBottom = false;                dO.moveToX( dO.newX );                dO.moveToY( dO.newY );                carryGroup(distX, distY);                if(hasOnDrag)                    dO.ondrag(e);            }                       // Handle dropTarget dragOver            var _dragOverTargets = dO._dragOverTargets;                if(_dragOverTargets !== false)  {                var coords = { x:ePageX, y:ePageY },                    i = 0,                     j = _dragOverTargets.length,                    dt,                    isInTarget,                    dragEvent = {domEvent:e, dragObj:dO};                               for(; i < j; i++) {                    dt = _dragOverTargets[i],                        isInTarget = dt.containsCoords(coords);                    // Did we just move over this dropTarget?                        if(!dt.hasDropTargetOver && isInTarget) {                        dt.hasDropTargetOver = true;                           if(typeof dt.ondragover == "function")                            dt.ondragover(dragEvent); // typeof check now needed.                        if(dt.dragOverClassName)                            dom.addClass(dt.el, dt.dragOverClassName);                    }                    else { // Were we previously over this dropTarget?                        if(dt.hasDropTargetOver && !isInTarget) {                             if(typeof dt.ondragout == "function")                                dt.ondragout(dragEvent);                            if(dt.dragOverClassName)                                dom.removeClass(dt.el, dt.dragOverClassName);                            dt.hasDropTargetOver = false;                        }                    }                }            }            return false;        }                function mouseUp(e) {        // IE will fire this event twice when mouse was held.            // IE fires mousemoves randomly, usually when the mouse is held.            // For this case, just let dragDone run it's course and fire it's event.             var isRandomMouseMoveEvent = (dO && dO.isBeingDragged && !dO.hasBeenDragged);            if(dO === null || !dO.hasBeenDragged && !isRandomMouseMoveEvent) {                return;            }                if(!e)                e = event;                        var id, item;            if(dO.copyEl)                 retireClone(dO);            for(id in draggableList) {                item = draggableList[id];                if(item.copyEl)                     retireClone(item);            }                        // if it's been dragged onto a dropTarget, fire that event.            var targets = dO.dropTargets,                len = targets.length, o, x, y;            if(len > 0) {                var coords = getEventCoords(e),                    dropTarget, i = 0;                for(; i < len; i++) {                    dropTarget = targets[i];                        if(dropTarget.containsCoords(coords)) {                        dropTarget.containsCoords(coords);                            if(typeof dropTarget.ondrop == "function")                            dropTarget.ondrop({domEvent:e, dragObj:dO, dropTarget:dropTarget});                                                    for(id in draggableList)  { // Assume that draggable groups share dropTargets.                            if(id === dropTarget.id) continue;                            if(typeof dropTarget.ondrop == "function") {                                o = draggableList[id];                                dropTarget.ondrop({domEvent:e, dragObj:o, dropTarget:dropTarget});                             }                        }                        if(dropTarget.dragOverClassName)                            dom.removeClass(dropTarget.el, dropTarget.dragOverClassName);                        break;                    }                }            }            for(id in draggableList) {                o = draggableList[id],                     x = o.x, y = o.y;                if(x < o.minX)                    o.moveToX(o.minX);                else if(x > o.maxX)                    o.moveToX(o.maxX);                if(y < o.minY)                    o.moveToY(o.minY);                else if(y > o.maxY)                    o.moveToY(o.maxY);                if(o.hasBeenDragged)                    dragDone(o, e);            }            dragDone(dO, e);            dO = null;        }        /**          * Key event callback handler.          * When ESC key is pressed,          * draggables are released.         */        function keyPressed(e) {            e=e||self.event;            if(e.keyCode == 27) { // esc key.                if(dO) {                    dO.release(e);                }            }        }            return {            /** @type {boolean}              * @description set to true to make a temporary "ghost" copy dragged.             */            dragCopy : false,                    /** @type {boolean}              * @description set to true to allow this to be dragged as a group.             */            dragMultiple : false,                     isSelected : false,                /**         *  A subset of dropTargets that have ondragover or ondragout.         *  created onmousedown, to help boost performance by reducing count for ondragover          *              **/                        _dragOverTargets : false,                       /** @event            * @description Is about to move.            */           onbeforedrag : undefined,                   /** @event            * @description Has been grabbed.            */           onbeforedragstart : undefined,           /** @event            *  @param {Event} e dom event.            * Mouse has moved.            */           ondragstart : undefined,                        /** @event            *  @param {Event} e dom event.            *  @description Being dragged            */           ondrag : undefined,                    /** @event            *  @description Dragging stopped before it escaped its container.             */           ondragstop : undefined,                    /** @event            *  @description Dragging completed (as a result of mouseup).             */           ondragend : undefined,                             /**@type {Number}              * @description current x position*/            x : 0,            /**@type {Number}              * @description current y position*/            y : 0,            /**@type {Number}              * @description where drag started from */            origX : 0,            /**@type {Number}              * @description where drag started from */            origY : 0,            /**@type {Number}              * @description where draggable was grabbed from */            grabX : 0,            /**@type {Number}              * @description where draggable was grabbed from */            grabY : 0,                    /** @type {Number}              * @description Where it will move to next. onbeforedrag */            newX : 0,             /** @type {Number}              * @description Where it will move to next. onbeforedrag */            newY : 0,                    /** @type {boolean}              * @description drag object can be dragged outside of its container */            keepInContainer : false,            /** @type {boolean}              * @description drag object can be disabled by setting to this to false */            isDragEnabled : true,                        /** @type {String}              * @description className to add when selected. */            selectedClassName : "",            /** @type {String}              * @description className to add before being dragged. */            activeDragClassName : "",            useHandleTree : true,                    hasHandleSet : false,                    /** Sets a handle on a draggable              * @param {HTMLElement} el the element to use as a handle.             * By default, the handle is the draggable.             * @param {boolean} [setHandleTree] if true, the draggable can use anything in the              * handle's subtree for dragging.             */            setHandle : function(el, setHandleTree){                this.handle = el;                this.hasHandleSet = true;                // Make sure user didn't forget the secondParam and expect true.                this.useHandleTree = setHandleTree != false;            },                        /**              * Adds a drop target.             * @param {HTMLElement|APE.drag.DropTarget} dropTarget either an element or a DropTarget.             * @return {DropTarget} The drop target that was added.             */            addDropTarget : function(dropTarget) {                var dt = DropTarget.getByNode(dropTarget),                    el = dt.el,                    dropTargets = this.dropTargets;                if(this.el === el) return dt;                return dropTargets[dropTargets.length] = DropTarget.getByNode(el);            },                        /**              * Grabs the draggable, centering it under the cursor.             * @param {Event} e the event to grab the element from.             * @param {int} [xOffset] amount of horizontal adjustment to apply.             * @param {int} [xOffset] amount of vertical adjustment to apply.             */            grab : function(e, xOffset, yOffset) {                if(!e) e = self.event;                                var Event = dom.Event,                    target = Event.getTarget(e);                        if(e.preventDefault) e.preventDefault();                e.returnValue = false;                                if(dom.contains(this.el, target)) return;                                    var grabCoords = dom.getPixelCoords(this.el);                        this.grabX = grabCoords.x;                this.grabY = grabCoords.y;                                // Get the container's offset.                var eventCoords = Event.getCoords(e),                    offsetCoords = dom.getOffsetCoords(dom.getContainingBlock(this.el)),                    offsetY = eventCoords.y - offsetCoords.y,                    newY = Math.floor(offsetY - (this.handle.offsetHeight/2)),                    handleOffsetCoords = dom.getOffsetCoords(this.handle, this.el);                                var offsetX = eventCoords.x - offsetCoords.x,                    newX = offsetX - Math.floor((this.handle.offsetWidth/2));                if(this.keepInContainer) {                    newX = Math.max(newX, 0);                    newX = Math.min(newX, this.container.clientWidth - this.el.offsetWidth);                    newY = Math.max(newY, 0);                    newY = Math.min(newY, this.container.clientHeight - this.el.offsetHeight);                }                this.moveToX(newX- handleOffsetCoords.x + (xOffset||0));                this.moveToY(newY - handleOffsetCoords.y + (yOffset||0));                                    dragObjGrabbed(e, this);                    dO = this;            },                        /** @private             * @type {APE.drag.DropTarget[]|boolean}             * @description An array of DropTarget that has one of:              * an ondragover or ondragout handler             * a hoverClassName             */            _dragOverTargets : false,                            /**             * releases the draggable, as if the mouse had been released.             * @param {Event} [e] the event that triggered release             */            release : function(e) {                dragObjReleased(e, this);                if(typeof this.onrelease == "function")                     this.onrelease(e);            },                            moveToX : function(x) {                this.style[LSTYLE] = (this.x = x) + PIXEL_PX;            },                        moveToY : function(y) {                this.style[TSTYLE] = (this.y = y) + PIXEL_PX;            },                        /**             * @private             */            glideStart : function(x, y) {            // Would be cleaner to separate this concern; APE.drag.Draggable should not have to concern itself             // for animation and notifying subscribers of onglide, et c.                        if(this.animTimer) return;                                this.startX = x;                this.startY = y;                        var dx = this.startX - this.grabX,                    dy = this.startY - this.grabY;                        // Calculate Hypoteneuse.                this.glideDist = Math.ceil(Math.sqrt((dx * dx) + (dy * dy)));                        if(this.glideDist === 0) return;                this.rx = Math.abs(dx)/this.glideDist;                this.ry = Math.abs(dy)/this.glideDist;                if(this.x > this.grabX)                    this.rx = -this.rx;                if(this.y > this.grabY)                    this.ry = -this.ry;                                this.startTime = +new Date;                this.animTimer = self.setInterval("APE.drag.Draggable.instances['"+this.id+"'].glide()", 10);            },                    /**             * @private             */            glide : function() {                var t = new Date - this.startTime,                // 2px per 10ms slight acceleration 10px/s                    d = Math.ceil(2 * t + .5 * .01 * t*t);                        if(d >= this.glideDist) {                    this.animTimer = self.clearInterval(this.animTimer);                    this.moveToX( this.grabX );                    this.moveToY( this.grabY );                    if(this.copyEl) {                        this.el = this.origEl;                        this.style = this.origEl.style;                        this.copyEl.style.display = "none";                    }                    if(typeof this.onglide == "function")                        this.onglide();                    if(typeof this.onglideend == "function")                        this.onglideend();                    dragDone(this, {});                } else {                     this.moveToX(this.startX + d * this.rx);                     this.moveToY(this.startY + d * this.ry);                    if(typeof this.onglide == "function")                        this.onglide();                }            },                        /** Starts gliding the draggable back to its original x,y coords.              * @param {Number} [x] x coordinate to start gliding from.             * @param {Number} [y] y coordinate to start gliding from.             */            animateBack : function(x, y) {                this.glideStart(x||this.x, y||this.y);            },                                    /**              * Removes a drop target.             * @param {HTMLElement|DropTarget} element or DropTarget to remove.             * @return {HTMLElement} the removed dropTarget element.             */            removeDropTarget : function(el){                el = document.getElementById(el.id);                                 for(var i = 0, len = this.dropTargets.length; i < len; i++) {                    if(this.dropTargets[i].el === el) {                        this.dropTargets.splice(i, 1);                        return el;                    }                }                return null;            },                                toString : function() { return "APE.drag.Draggable(id=" +this.id +")"; }        };        }    /**      * called before dragstart, this function checks to see if there are any droptargets      * that need mousemove consideration. For example, if the droptarget has a     * dragOverClassName, or has an ondragover handler.     * @private     */    function _setUpDragOver(dO) {        // subset for ondragover, to help speed up dragging         // with multiple drop targets.        dO._dragOverTargets = [];        var dropTargets = dO.dropTargets,            dt, i = 0, len = dropTargets.length;                for(; i < len; i++) {            dt = dropTargets[i];            dt.initCoords();            if(typeof dt.ondragover == "function" ||                     typeof dt.ondragout == "function" || dt.dragOverClassName)                 dO._dragOverTargets.push(dt);        }        // set to false, for quicker access on drag over.        if(dO._dragOverTargets.length === 0)             dO._dragOverTargets = false;    };        var DropTarget = drag.DropTarget = APE.createFactory(DropTargetC, createDropTargetPrototype);    /** APE.drag.DropTarget     *     * @param{HTMLElement} el      * private constructor - use draggable.addDropTarget(el);     * @private      */    function DropTargetC(el) {        this.el = el;        this.id = el.id;    };    function createDropTargetPrototype(){        return {                    /** @type {Object}              * @description {x,y} coords of DropTarget */            coords : undefined,                    /** @type {String}              * @description the className to add when selected. */            dragOverClassName : "",                    initCoords : function() {                if(!this.coords) this.coords = {};                dom.getOffsetCoords(this.el, document, this.coords);                this.coords.w = this.el.clientWidth;                this.coords.h = this.el.clientHeight;            },                    /**  checks to see if the coordinates              *  x and y are both inside dropTarget             * @param {Object} curs {x,y} coordinates of the event.             */            containsCoords : function(curs) {                 // check for x, then y.                var dt_x = this.coords.x, dt_y = this.coords.y;                                return (curs.x >= dt_x && curs.x <= dt_x + this.coords.w)                    && // now check for y.                    (curs.y >= dt_y && curs.y <= dt_y + this.coords.h);            },                    /**             * @event             * Dragged over a droptarget */            ondragover : false,             /**             * @event             * Dragged off a droptarget */            ondragout : undefined,                    /**             * @event             * Hit a drop target. Fires for each object being dragged. */            ondrop : undefined        };    }    })();